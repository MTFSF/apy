<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>服务器跳转/恢复倒计时</title>
    <style>
        body {
            background-color: #000000;
            color: #00FF00;
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-size: 2em;
        }
        #jump-container {
            text-align: center;
            line-height: 1.8;
        }
        #countdown {
            text-align: center;
        }
        .getting {
            color: #FFFF00 !important;
        }
        .error {
            color: #FF0000 !important;
        }
        a {
            color: #00FFFF;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <!-- 初始跳转容器 -->
    <div id="jump-container">
        正在解析服务器地址...<br>
        <span id="status">解析中......</span>
    </div>
    <!-- 倒计时容器（初始隐藏） -->
    <div id="countdown" style="display: none;">
        服务器预计还有 <span id="time">加载中...</span> 后恢复
    </div>

    <script>
        // ========== cpolar 配置 ==========
        const CPOLAR_AUTHTOKEN = "MTA3YjBiNmYtY2RjNC00YzM5LWE3N2ItZGVlYzBiZWU2ZjYy";
        const CPOLAR_LOCAL_API = "http://localhost:4040/api/tunnels";
        const CPOLAR_REMOTE_API = "https://api.cpolar.com/v1/tunnels";
        const maxRetries = 3; // 最大重试次数
        
        // 状态常量（跳转阶段）
        const STATE_PARSING = 'parsing';    // 初始解析
        const STATE_RETRYING = 'retrying';  // 重试中
        const STATE_JUMPING = 'jumping';    // 跳转中

        // 全局变量（跳转阶段）
        let currentJumpState = STATE_PARSING;
        let retryCount = 0;
        let isProcessing = false;

        const jumpContainer = document.getElementById('jump-container');
        const statusElement = document.getElementById('status');
        const countdownContainer = document.getElementById('countdown');

        // ========== 跳转阶段工具函数 ==========
        // 更新跳转状态显示
        function updateJumpDisplay(text, state) {
            if (currentJumpState === state && statusElement.textContent === text) return;
            
            statusElement.textContent = text;
            statusElement.classList.remove('getting', 'error');
            
            if (state === STATE_RETRYING) {
                statusElement.classList.add('getting');
            }
            currentJumpState = state;
        }

        // 解码Base64格式的AUTHTOKEN
        function decodeBase64(str) {
            try { return atob(str); } 
            catch (e) { return str; }
        }

        // ========== cpolar API 逻辑 ==========
        // 1. 优先调用本地API
        async function getCpolarTunnelLocal() {
            try {
                const response = await fetch(CPOLAR_LOCAL_API, { method: 'GET', timeout: 3000 });
                if (!response.ok) throw new Error("本地API响应失败");
                
                const data = await response.json();
                const httpsTunnel = data.tunnels.find(t => t.proto === 'https');
                if (httpsTunnel) return httpsTunnel.public_url;
                
                throw new Error("未找到HTTPS隧道");
            } catch (e) {
                console.error("本地API失败:", e.message);
                return getCpolarTunnelRemote(); // 降级到远程API
            }
        }

        // 2. 备用：远程API
        async function getCpolarTunnelRemote() {
            const decodedToken = decodeBase64(CPOLAR_AUTHTOKEN);
            try {
                const response = await fetch(CPOLAR_REMOTE_API, {
                    method: 'GET',
                    headers: { 'Authorization': `Bearer ${decodedToken}`, 'Content-Type': 'application/json' },
                    timeout: 5000
                });
                if (!response.ok) throw new Error(`远程API错误: ${response.status}`);
                
                const data = await response.json();
                const httpsTunnel = data.tunnels.find(t => t.proto === 'https');
                if (httpsTunnel) return httpsTunnel.public_url;
                
                throw new Error("远程未找到HTTPS隧道");
            } catch (e) {
                console.error("远程API失败:", e.message);
                throw e; // 抛出错误让上层处理
            }
        }

        // ========== 核心跳转逻辑 ==========
        async function jumpToServer() {
            if (isProcessing) return;
            isProcessing = true;

            try {
                // 初始解析状态
                updateJumpDisplay("解析中......", STATE_PARSING);
                
                // 获取HTTPS地址
                const httpsUrl = await getCpolarTunnelLocal();
                if (!httpsUrl) throw new Error("未获取到有效HTTPS地址");
                
                // 跳转逻辑
                updateJumpDisplay(`跳转至 ${httpsUrl}`, STATE_JUMPING);
                jumpContainer.innerHTML = `
                    即将跳转至服务器...<br>
                    <span style="color:#00FF00">跳转中......</span><br>
                    若未自动跳转，请点击 <a href="${httpsUrl}">这里</a>
                `;
                setTimeout(() => window.location.href = httpsUrl, 1000);

            } catch (error) {
                console.error(`跳转失败 (${retryCount + 1}/${maxRetries}):`, error.message);
                
                retryCount++;
                if (retryCount < maxRetries) {
                    // 重试提示：黄字显示 (1/3)/(2/3)
                    updateJumpDisplay(`解析失败，重试中(${retryCount}/${maxRetries})...`, STATE_RETRYING);
                    setTimeout(() => {
                        isProcessing = false;
                        jumpToServer(); // 重新执行跳转逻辑
                    }, 2000);
                } else {
                    // 三次重试失败 → 切换到原版倒计时
                    isProcessing = false;
                    jumpContainer.style.display = 'none';
                    countdownContainer.style.display = 'block';
                    initCountdown(); // 启动原版倒计时
                }
            }
            
            isProcessing = false;
        }

        // ========== 原版完整倒计时逻辑（完全保留） ==========
        function initCountdown() {
            // 状态常量
            const STATE_NORMAL = 'normal';
            const STATE_RETRYING = 'retrying';
            const STATE_ERROR = 'error';

            let currentState = STATE_NORMAL;
            let retryCount = 0;
            const maxRetries = 3;
            let isUpdating = false;

            const timeElement = document.getElementById('time');

            function formatTime(seconds) {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = seconds % 60;
                return `${String(hours).padStart(2, '0')}.${String(minutes).padStart(2, '0')}.${String(secs).padStart(2, '0')}`;
            }

            // 更新DOM显示（只在状态变化时调用）
            function updateDisplay(text, state) {
                if (currentState === state && timeElement.textContent === text) {
                    return; // 状态和内容都没变，不更新DOM
                }

                timeElement.textContent = text;
                timeElement.classList.remove('getting', 'error');
                
                switch(state) {
                    case STATE_RETRYING:
                        timeElement.classList.add('getting');
                        break;
                    case STATE_ERROR:
                        timeElement.classList.add('error');
                        break;
                }
                
                currentState = state;
            }

            // 核心倒计时逻辑（不直接操作DOM）
            async function calculateTime() {
                const response = await fetch('time.json');
                
                if (!response.ok) {
                    throw new Error(`HTTP错误: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data['count-down-time'] === undefined || data['unix-time'] === undefined) {
                    throw new Error('JSON数据格式错误');
                }
                
                const currentUnixTime = Math.floor(Date.now() / 1000);
                const endTime = data['unix-time'] + data['count-down-time'];
                
                if (currentUnixTime >= endTime) {
                    return '00.00.00';
                } else {
                    return formatTime(endTime - currentUnixTime);
                }
            }

            // 主更新函数
            async function updateCountdown() {
                if (isUpdating) return;
                isUpdating = true;

                try {
                    const timeText = await calculateTime();
                    
                    // 成功，重置状态
                    retryCount = 0;
                    updateDisplay(timeText, STATE_NORMAL);
                    
                } catch (error) {
                    console.error(`读取失败 (${retryCount + 1}/${maxRetries}):`, error.message);
                    
                    if (retryCount === 0) {
                        // 第一次失败：显示Getting time
                        updateDisplay('Getting time', STATE_RETRYING);
                    }
                    
                    retryCount++;
                    
                    if (retryCount >= maxRetries) {
                        // 三次失败：显示ERROR
                        updateDisplay('ERROR, Could not connect to time server', STATE_ERROR);
                        retryCount = 0;
                    }
                }
                
                isUpdating = false;
            }

            // 重试机制（独立定时器）
            function startRetryMechanism() {
                setInterval(() => {
                    // 只在重试状态且未达最大次数时才额外调用
                    if (currentState === STATE_RETRYING && retryCount > 0 && retryCount < maxRetries) {
                        updateCountdown();
                    }
                }, 1000);
            }

            // 主定时器（每秒执行）
            function startMainLoop() {
                updateCountdown(); // 立即执行
                
                setInterval(() => {
                    // 不在ERROR状态时才继续更新
                    if (currentState !== STATE_ERROR) {
                        updateCountdown();
                    }
                }, 1000);
            }

            // 启动倒计时
            startRetryMechanism();
            startMainLoop();
        }

        // ========== 启动核心流程 ==========
        jumpToServer();
    </script>
</body>
</html>
