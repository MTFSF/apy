<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>服务器恢复倒计时</title>
    <style>
        body {
            background-color: #000000;
            color: #00FF00;
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-size: 2em;
        }
        #countdown {
            text-align: center;
        }
        .getting {
            color: #FFFF00 !important;
        }
        .error {
            color: #FF0000 !important;
        }
    </style>
</head>
<body>
    <div id="countdown">服务器预计还有 <span id="time">加载中...</span> 后恢复</div>

    <script>
        // 状态常量
        const STATE_NORMAL = 'normal';
        const STATE_RETRYING = 'retrying';
        const STATE_ERROR = 'error';

        let currentState = STATE_NORMAL;
        let retryCount = 0;
        const maxRetries = 3;
        let isUpdating = false;

        const timeElement = document.getElementById('time');

        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            return `${String(hours).padStart(2, '0')}.${String(minutes).padStart(2, '0')}.${String(secs).padStart(2, '0')}`;
        }

        // 更新DOM显示（只在状态变化时调用）
        function updateDisplay(text, state) {
            if (currentState === state && timeElement.textContent === text) {
                return; // 状态和内容都没变，不更新DOM
            }

            timeElement.textContent = text;
            timeElement.classList.remove('getting', 'error');
            
            switch(state) {
                case STATE_RETRYING:
                    timeElement.classList.add('getting');
                    break;
                case STATE_ERROR:
                    timeElement.classList.add('error');
                    break;
            }
            
            currentState = state;
        }

        // 核心倒计时逻辑（不直接操作DOM）
        async function calculateTime() {
            const response = await fetch('time.json');
            
            if (!response.ok) {
                throw new Error(`HTTP错误: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data['count-down-time'] === undefined || data['unix-time'] === undefined) {
                throw new Error('JSON数据格式错误');
            }
            
            const currentUnixTime = Math.floor(Date.now() / 1000);
            const endTime = data['unix-time'] + data['count-down-time'];
            
            if (currentUnixTime >= endTime) {
                return '00.00.00';
            } else {
                return formatTime(endTime - currentUnixTime);
            }
        }

        // 主更新函数
        async function updateCountdown() {
            if (isUpdating) return;
            isUpdating = true;

            try {
                const timeText = await calculateTime();
                
                // 成功，重置状态
                retryCount = 0;
                updateDisplay(timeText, STATE_NORMAL);
                
            } catch (error) {
                console.error(`读取失败 (${retryCount + 1}/${maxRetries}):`, error.message);
                
                if (retryCount === 0) {
                    // 第一次失败：显示Getting time
                    updateDisplay('Getting time', STATE_RETRYING);
                }
                
                retryCount++;
                
                if (retryCount >= maxRetries) {
                    // 三次失败：显示ERROR
                    updateDisplay('ERROR, Could not connect to time server', STATE_ERROR);
                    retryCount = 0;
                }
            }
            
            isUpdating = false;
        }

        // 重试机制（独立定时器）
        function startRetryMechanism() {
            setInterval(() => {
                // 只在重试状态且未达最大次数时才额外调用
                if (currentState === STATE_RETRYING && retryCount > 0 && retryCount < maxRetries) {
                    updateCountdown();
                }
            }, 1000);
        }

        // 主定时器（每秒执行）
        function startMainLoop() {
            updateCountdown(); // 立即执行
            
            setInterval(() => {
                // 不在ERROR状态时才继续更新
                if (currentState !== STATE_ERROR) {
                    updateCountdown();
                }
            }, 1000);
        }

        // 启动
        startRetryMechanism();
        startMainLoop();
    </script>
</body>
</html>
